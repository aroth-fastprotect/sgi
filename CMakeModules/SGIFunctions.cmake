FUNCTION(TO_LIST_NEWLINES _LIST_NAME OUTPUT_VAR)
    set(NEW_LIST_NEWLINES)
    foreach(ITEM ${${_LIST_NAME}})
        set(NEW_LIST_NEWLINES "${NEW_LIST_NEWLINES}\n${ITEM}")
    endforeach()
    set(${OUTPUT_VAR} "${NEW_LIST_NEWLINES}" PARENT_SCOPE)
ENDFUNCTION()

FUNCTION(TO_LIST_COMMA _LIST_NAME OUTPUT_VAR)
    set(NEW_LIST_SPACE)
    foreach(ITEM ${${_LIST_NAME}})
        if(NEW_LIST_SPACE)
            set(NEW_LIST_SPACE "${NEW_LIST_SPACE}, ${ITEM}")
        else()
            set(NEW_LIST_SPACE "${ITEM}")
        endif()
    endforeach()
    string(STRIP ${NEW_LIST_SPACE} NEW_LIST_SPACE)
    set(${OUTPUT_VAR} "${NEW_LIST_SPACE}" PARENT_SCOPE)
ENDFUNCTION()

MACRO(SGI_PLUGIN_HOST_SUPPORT name)
    string(TOUPPER ${name} _var_name)
    IF(SGI_PLUGIN_${_var_name})
        string(TOLOWER ${name} _support_name)
        LIST(APPEND SGI_PLUGIN_HOST_SUPPORT_INCLUDES "#include \"${_support_name}_support.h\"")
        LIST(APPEND SGI_PLUGIN_HOST_SUPPORT_ITEM_CLASSES ${ARGN})
    ENDIF()
ENDMACRO(SGI_PLUGIN_HOST_SUPPORT)

FUNCTION(SGI_CREATE_SYMLINK src_file dest_file)
    if(UNIX)
        execute_process(COMMAND ${CMAKE_COMMAND} -E create_symlink ${CMAKE_CURRENT_SOURCE_DIR}/${src_file} ${dest_file})
    else()
        # Generate a "wrapper" header file to simulate a symlink for this poor OS (win32). But this does 
        # not work when the "wrapper" header file is installed as public header file. Therefore we use
        # cmake copy to avoid this issue.
        #file(WRITE ${dest_file} "#include \"${CMAKE_CURRENT_SOURCE_DIR}/${src_file}\"\n")
        execute_process(COMMAND ${CMAKE_COMMAND} -E copy_if_different ${CMAKE_CURRENT_SOURCE_DIR}/${src_file} ${dest_file})
    endif()
ENDFUNCTION(SGI_CREATE_SYMLINK)
